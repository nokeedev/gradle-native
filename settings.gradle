pluginManagement {
	includeBuild 'gradle/plugins/docs-gradle-plugin'
	includeBuild 'gradle/plugins/jbake-gradle-plugin'
	includeBuild 'gradle/plugins/documentation-kit-plugins'
	includeBuild 'gradle/plugins/nokeebuild-plugins'
	includeBuild 'gradle/plugins/nokeedocs-plugins'
}

plugins {
	id 'dev.gradleplugins.gradle-plugin-development' version '1.6.7'
	id 'com.gradle.enterprise' version '3.8.1'
}

rootProject.name = 'gradle-native'

includeBuild 'subprojects/templates'
includeBuild 'gradle/plugins/docs-gradle-plugin'
includeBuild 'gradle/plugins/license-gradle-plugin'

/**
 * Adds specified subproject path to this Gradle build.
 *
 * @param path  the subproject path under {@literal subprojects} folder, must not be null
 * @param closure  a subproject {@link ProjectDescriptor} configuration closure, must not be null
 */
void subproject(String path, Closure closure = {}) {
	def tokens = path.split('/')
	def projectName = tokens.collect { name -> name.split('-').collect { it.capitalize() }.join().uncapitalize() }
	def projectPath = projectName.join(':')
	include(projectPath)
	project(":${projectPath}").projectDir = file("subprojects/${path}")
	project(":${projectPath}").buildFileName = "${tokens.join('-')}.gradle"

	closure.delegate = project(":${projectPath}")
	closure.resolveStrategy = Closure.DELEGATE_FIRST
	closure.call(project(":${projectPath}"))
}

subproject('build-adapter-cmake')
subproject('core-exec')
subproject('core-model')
subproject('core-model')
subproject('core-script')
subproject('core-utils')
subproject('distributions')
subproject('distributions/all')
subproject('distributions/bom')
subproject('docs')
subproject('docs/exemplar-kit') {
	buildFileName = 'exemplar-kit.gradle'
}
subproject('gradle-annotation')
subproject('gradle-api')
subproject('gradle-shim')
subproject('ide-base')
subproject('ide-visual-studio')
subproject('ide-xcode')
subproject('internal-smoke-test')
subproject('internal-testing')
subproject('language-base')
subproject('language-c')
subproject('language-cpp')
subproject('language-native')
subproject('language-objective-c')
subproject('language-objective-cpp')
subproject('language-swift')
subproject('platform-base')
subproject('platform-c')
subproject('platform-cpp')
subproject('platform-native')
subproject('platform-objective-c')
subproject('platform-objective-cpp')
subproject('platform-swift')
subproject('platform-ios')
subproject('platform-jni')
subproject('publishing-core')
subproject('runtime-base')
subproject('runtime-native')
subproject('runtime-darwin')
subproject('runtime-windows')
subproject('testing-base')
subproject('testing-native')
subproject('testing-xctest')

import java.util.Optional
buildCache {
	remote(HttpBuildCache) {
		Optional.ofNullable(System.getProperty('gradle.cache.remote.url')).ifPresent { url = it }
		credentials {
			username = System.getProperty('gradle.cache.remote.username')
			password = System.getProperty('gradle.cache.remote.password')
		}
		enabled = credentials.username != null && credentials.password != null
		push = System.getenv().containsKey('CI')
	}
}

// We prefer using `--scan` flag because...
//   We would be left playing a cat & mouse game with the enterprise plugin
//   to figure out which version should match our build.
plugins.withId('com.gradle.enterprise') {
	gradleEnterprise {
		buildScan {
			server = System.getProperty('gradle.enterprise.url', null)
			termsOfServiceUrl = "https://gradle.com/terms-of-service"
			termsOfServiceAgree = "yes"
			publishAlways()

			if (System.getenv('CI')) {
				tag 'CI'
			} else {
				tag 'LOCAL'
			}

			uploadInBackground = System.getenv("CI") == null
			capture {
				taskInputFiles = true
			}
		}
	}
}
